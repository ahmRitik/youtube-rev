"""Youtube video scrapper or downloader based on reversing youtube ,

i find only way of getting youtube json call by embedding the youtube url , 
but there is drawback this script , this script can't download to those videos which can't be embedded.
you can see some video on youtube app are can't be save offline those are the these unembeddable videosüòÅ 

i removed the unnessery headers and data call from script 
i am not sure whether it will still be working or not 
but now its working fine for now , did't have any idea about future.

Only used request library for get post requests"""


import requests

class YoutubeRev(object):
	
	#slots remove unnecessary function related object and only permit thode varibles which you have given in paranethesis
	#Profit less memory use and faster acces (lol but this script is not even 100 lines )
	__slots__ = ('videoId' , 'baseUrl', 'headers' , 'key' , 'payloadData' , 'jsonData' , 'filter')

	def __init__(self , videoId):
		self.videoId = videoId
		self.baseUrl = "https://www.youtube.com/youtubei/v1/player"
		self.headers = {
		'user-agent':'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/88.0.4324.96 Safari/537.36',
		'content-type': 'application/json',
		'referer': 'https://www.youtube.com/embed/'+self.videoId
		}
		"""This api key was generated by my brwoser , i think its reusable
			this worked for me . not sure whether it will for you or not xD""" 
		self.key = "AIzaSyAO_FJ2SlqU8Q4STEHLGCilw_Y9_11qcW8"
		self.payloadData = {
			"videoId":self.videoId,
			"context": {
			    "client": {
				    #I literally don't know what shit is this , i tried filtering out this but did't worked out so i leave it at it is
				    #I think its dynamic ,i m not sure though maybe worked out for you too :)
			      "visitorData": "CgtRQ1VwRWtZTm9YayiG3OCABg%3D%3D",
			      "clientName": "WEB_EMBEDDED_PLAYER", #Too fool google that this is just a embedded video xD
			      "clientVersion": "20210126",
			    },
			},

			"cpn": "79JIqSkI_5iSwavl" #Another shit leave it at it is 
		}
		self.jsonData = dict(self._retriveJson())
		self.filter = dict(self._filteredData())

	def _retriveJson(self):
		res = requests.post(self.baseUrl , headers=self.headers , params={"key":self.key} , json=self.payloadData)
		if res.status_code != 200:
			raise Exception("Failed to retrive data , check url or this script is dead lol")
		else:
			return res.json()


	def _filteredData(self):
		junkFiltered = {
		"adaptiveVideos":[],
		"audios":[],
		"videos": self.jsonData['streamingData']['formats']
		}
		for obj in self.jsonData['streamingData']["adaptiveFormats"]:
			if "qualityLabel" in obj.keys():
				junkFiltered["adaptiveVideos"].append(obj)
			else:
				junkFiltered["audios"].append(obj)
		return junkFiltered

	def videoData(self):
		try:
			return self.jsonData['streamingData']
		except Exception:
			raise KeyError("Key is missing , failed to retrive video is not downloadable")

	def videoInfo(self):
		try:
			return self.jsonData["videoDetails"]
		except Exception:
			raise KeyError("Key is missing , failed to retrive ")
			
			
			
#Instantiate an object by passing videoId of youtube video
# y1 = YoutubeRev("17qbqlCgyEg")

#y1.videoData() #Return all the video json data
#y1.videoInfo() #Return all the video meta data such as title description 
#y1.jsonData() #Return all the json data without filtering and formatting

#This can filter the json data accoriding to your choice
#(y1.filter["adaptiveVideos"])#This contain video url of highest quality video but audio are absent
#(y1.filter["audios"])#This contain audio link of that video do note youtube Audio are in webm format you have to encode in mp3
#(y1.filter["videos"])#This contain link of that video in which both audio and video is available

#More Feature will be added later 


